Gemini Conductor」是 Google 為 **Gemini CLI**（命令列介面）推出的一款官方擴充功能，旨在將 AI 輔助軟體開發從單純的「對話式」轉向「**脈絡驅動（Context-Driven）**」與「**規劃優先**」的模式。

簡單來說，它能將開發過程中的專案資訊（如產品目標、技術架構）從容易遺失的聊天紀錄中，轉移到專案內部的 Markdown 檔案（如 plan.md、spec.md），使 AI 與開發者能共享同一個「真理來源」（Source of Truth）。

---

## **Gemini Conductor 的核心功能**

### **1. 脈絡化開發（Context-Driven Development）**

傳統的 AI 對話工具常在關閉視窗或更換會話後就失去專案背景。Conductor 將專案資訊持久化存儲於版本控制系統（如 Git）中。

* **專案設定：** 透過 `/conductor:setup` 定義產品目標、技術棧（Tech Stack）和開發流程偏好（例如：遵循 TDD 測試驅動開發）。  
* **共享標準：** 團隊成員可以共用相同的配置，確保 AI 產出的程式碼風格一致。

### **2. 軌跡系統（Tracks）**

Conductor 引入了「軌跡（Track）」的概念，將每個功能開發或 Bug 修復視為獨立的工作單元。

* **先規劃後動手：** 在生成程式碼前，Conductor 會引導開發者生成「規格書（Specs）」與「執行計畫（Plan）」。  
* **結構化任務：** 計畫會被拆解為多個階段與子任務，並直接在 Markdown 檔案中追蹤進度。

### **3. 自動化審查（Automated Reviews）**

這是 2026 年初新增的重要功能。AI 不僅能寫程式，還能在完成後自動進行審查：

* **邏輯與靜態分析：** 找出如非同步代碼中的競態條件（Race conditions）或潛在的空指標風險。  
* **規格檢核：** 自動對照 `spec.md` 檢查所有功能是否落實，並產出品質報告。

---

## **工作流程範例**

| 步驟 | 指令 | 目的 |
| :--- | :--- | :--- |
| **1. 初始化** | `/conductor:setup` | 定義專案的產品目標、程式語言偏好與編碼規範。 |
| **2. 建立任務** | `/conductor:newTrack` | 針對特定功能（如：新增登入介面）建立規格與詳細計畫。 |
| **3. 執行開發** | 根據計畫實作 | AI 與開發者共同完成計畫中的子任務。 |
| **4. 自動審查** | 自動觸發或指令 | 檢查程式碼品質是否符合專案定義的規範與 `plan.md` 的要求。 |

---

## **安裝方式**

若你已經安裝了 Gemini CLI，可以透過以下指令直接安裝 Conductor 擴充功能：

```bash
gemini extensions install https://github.com/gemini-cli-extensions/conductor
```

---

### **Q: 建立任務後，執行開發，程式測試後有問題，再建立任務後，進行 bugFix, 這樣是針對 bug 進行調整，或是整個專案重新再來一遍?**

**A:** 在 Gemini Conductor 的工作流程中，這絕對**不是整個專案重新再來一遍**，而是透過「軌跡（Tracks）」系統進行**精確的局部修正**。

Conductor 的設計初衷就是為了避免 AI 在處理大型專案時產生「幻覺」或改 A 壞 B。當測試出現問題時，它的處理邏輯如下：

#### **處理 Bug 的標準流程：局部迭代**

當你在執行開發並測試後發現問題，通常有兩種處理方式：

1. **在現有軌跡（Track）中修正**  
   如果 Bug 只是剛才開發的功能沒寫好，你不需要建立新任務。
   * **更新計畫：** 你可以要求 AI 更新現有的 `plan.md`，增加一個「Bug Fix」的子任務。  
   * **對症下藥：** AI 會讀取目前的規格書（Spec），確認是程式碼邏輯錯誤還是當初規格漏掉場景，然後只修改受影響的檔案。

2. **建立新的「修正軌跡」（BugFix Track）**  
   如果你已經完成了開發任務並關閉了該軌跡，後來才發現 Bug，這時會建立一個新的任務。
   * **繼承脈絡：** 新任務會讀取專案整體的 `context.md`。AI 知道之前的架構，它只會針對「Bug 現象」與「相關原始碼」進行分析。  
   * **差異化調整：** 它會生成一個專專針對該 Bug 的小型計畫，例如：  
     1. 重現 Bug 的單元測試。  
     2. 修正 `auth.ts` 中的邊界條件。  
     3. 驗證測試通過。

#### **為什麼不會「重新再來」？**

Gemini Conductor 透過以下機制確保開發是累積性的：

* **真理來源（Source of Truth）：** 因為所有的決策都記錄在 Markdown 檔案中，AI 下次啟動時，它是讀取這些檔案來「恢復記憶」，而不是重新猜測你的專案意圖。  
* **模組化處理：** Conductor 會引導 AI 只載入與該任務相關的檔案。如果你在修登入 Bug，它不會去動你的資料庫備份邏輯。  
* **版本控制友好：** 所有的變更都是透過 Git 進行的，你可以清楚看到 AI 修正了哪些行數，而不是整份檔案重寫。

#### **實際操作範例**

假設你的「使用者註冊」功能測試失敗（漏了驗證 Email 格式）：

1. **輸入指令：** `/conductor:newTrack fix-email-validation`  
2. **AI 分析：** 它會讀取 `register.ts` 並發現缺少 Regex 檢查。  
3. **產出計畫：** 在新的 `plan.md` 中只會列出「新增 Email 驗證」與「補足測試案例」兩個步驟。  
4. **執行：** 它只會修改該驗證函式，其餘已完成的資料庫寫入、UI 配置都會保持原樣。

**提示：** 這種方式能極大節省 Token 消耗，因為 AI 不需要處理整個專案的所有程式碼。

---

### **Q: 專案設定與共享標準描述不夠完善，如何加強?**

**A:** 要加強 **Gemini Conductor** 的專案設定與共享標準，核心在於將「模糊的口頭約定」轉化為「**機器可讀且具備約束力的文件**」。

如果設定不完善，AI 容易寫出風格不統一、不符合公司架構、甚至引用錯誤函式庫的程式碼。以下是從四個維度強化設定的具體作法：

#### **1. 完善核心設定文件 (`context.md` / `.conductor/config`)**

不要只寫「這是一個 React 專案」，應採用**結構化**的描述。

* **技術棧精確化：** 指定版本與核心套件（例如：使用 Tailwind CSS 而非 CSS Modules）。  
* **目錄規範：** 明確規定元件放在 `src/components/common`，Logic 放在 `src/hooks`。  
* **禁止事項（Negative Constraints）：** 明確告知 AI「禁止使用 any 型別」、「禁止使用 Axios，統一用原生 fetch」。

#### **2. 建立「風格指南軌跡」(Style Guide Track)**

在 Conductor 中，你可以建立一個專門存放「準則」的 Track。

* **實作：** 建立一個 `rules.md` 或在 `spec.md` 中定義 `Coding_Standards` 區塊。  
* **範例內容：**  
  * **命名慣例：** 元件檔案名必須是 PascalCase，Hook 必須是 useCamelCase。  
  * **錯誤處理：** 所有 API 呼叫必須包在 try-catch 中，並呼叫 `logger.error()`。  
  * **測試標準：** 每個新功能必須附帶單元測試，且覆蓋率需達 80%。

#### **3. 強化共享標準 (Shared Team Standards)**

為了讓團隊成員（與 AI）步調一致，應將 Conductor 的配置納入 **Git 版本控制**。

* **共享 Prompt 範本：** 在專案根目錄建立 `.conductor/prompts/`，存放通用的 PR 審查範本或 Commit Message 格式。  
* **標準化環境 (Infrastructure as Code)：** 如果專案有特定的 Docker 環境或 Linter 配置（如 ESLint, Prettier），請在 `context.md` 中指明「AI 產出的程式碼必須通過現有的 `npm run lint` 檢查」。

#### **4. 導入「真理來源」檢查清單**

在執行 `/conductor:setup` 時，請確保包含以下五大要素：

| 維度 | 強化內容建議 |
| :--- | :--- |
| **商務邏輯** | 專案的目標對象是誰？核心價值為何？（避免 AI 做出不合常理的 UI 決定） |
| **架構模式** | 是微服務還是單體？採用 MVC 還是 Clean Architecture？ |
| **API 規範** | 使用 RESTful 還是 GraphQL？分頁參數的統一名稱（例如：page vs offset）。 |
| **認證機制** | 統一使用 JWT 存放在 HttpOnly Cookie，嚴禁放在 LocalStorage。 |
| **CI/CD 流程** | 提交程式碼後會觸發哪些自動化測試？（讓 AI 知道它需要符合哪些自動化關卡）。 |

#### **實作建議：執行一次「重啟設定」**

如果現有專案設定太亂，建議執行以下操作：

1. **盤點現狀：** 執行 `/conductor:status` 查看目前 AI 認知的專案背景。  
2. **覆蓋更新：** 使用 `/conductor:setup --force` 並貼上整理後的結構化 Markdown。  
3. **建立驗證：** 建立一個小任務測試 AI 是否遵循新規則（例如：請它寫一個新元件，看它有沒有放在正確目錄並使用正確命名）。

---

### **Q: 這樣程式的規格，提供那些功能，可以處理什麼，是在專案設定描述或是軌跡系統（Tracks）?**

**A:** 這涉及到 Gemini Conductor 如何區分 **「長期架構」** 與 **「短期任務」** 的邏輯。

簡單來說：**「專案設定」是地基與藍圖，而「軌跡系統」是施工單。**

以下詳細說明兩者的分工：

#### **1. 專案設定 (Project Context / Setup)**

這裡描述的是 **「整體的、不常變動的」** 資訊。它定義了專案的邊界與規則。

* **應該寫在這裡的內容：**  
  * **專案願景：** 這個產品是做什麼的（例如：一個電商後台）。  
  * **全域功能概述：** 專案目前具備哪些核心模組（例如：會員系統、訂單系統、金流整合）。  
  * **技術規格：** 使用什麼語言、框架、資料庫、API 規範（REST 或 GraphQL）。  
  * **共用邏輯：** 例如「所有的資料權限都必須經過 AuthMiddleware 處理」。  
* **目的：** 讓 AI 擁有整體的「大局觀」，確保它在開發新功能時，不會寫出與現有系統衝突的程式碼。

#### **2. 軌跡系統 (Tracks)**

這裡描述的是 **「當下要做的、具體的」** 功能細節與執行步驟。

* **應該寫在這裡的內容（通常在 `spec.md` 或 `plan.md`）：**  
  * **具體功能需求：** 例如「新增一個匯出 CSV 報表的功能」。  
  * **詳細輸入輸出：** 點擊哪個按鈕、呼叫哪個 API、回傳什麼格式、UI 如何呈現。  
  * **錯誤處理流程：** 如果網路斷線或資料不存在，該功能要如何反應。  
  * **測試案例：** 該如何驗證這個功能是正確的。  
* **目的：** 讓 AI 專注於「這一次的任務」，將大目標拆解為可執行的步驟，並記錄進度。

#### **應對您的問題：規格與功能該放哪？**

這取決於該功能的 **「生命週期」**：

| 描述對象 | 放置位置 | 範例描述方式 |
| :--- | :--- | :--- |
| **已存在的穩定功能** | **專案設定** | 「系統目前支援 Google 與 GitHub 社交登入。」 |
| **準備要開發的新功能** | **軌跡系統 (Track)** | 「本次任務要在登入頁面新增『忘記密碼』連結，並發送驗證信。」 |
| **功能的通用開發標準** | **專案設定** | 「所有新開發的 UI 元件必須符合進階無障礙網頁規範 (WCAG)。」 |
| **特定功能的邏輯細節** | **軌跡系統 (Track)** | 「匯出功能必須限制在 5000 筆資料以內，超過要顯示警告。」 |

#### **實務上的最佳實踐**

1. **先在「專案設定」定義規範：** 告訴 AI「我們所有的規格都必須先寫在 `spec.md` 才能開始寫程式」。  
2. **透過「軌跡」進行開發：**  
   * 下令 `/conductor:newTrack [任務名稱]`。  
   * 在該 Track 下產生 `spec.md`（描述**做什麼**）。  
   * 在該 Track 下產生 `plan.md`（描述**怎麼做**）。  
3. **任務完成後回流：** 當一個 Track 完成並關閉後，重要的新增功能邏輯可以更新回「專案設定」文件中，成為下一個任務的背景知識。

**總結：** 如果你是要定義 **「這個專案是做什麼的」**，請放在 **設定**；如果你是要定義 **「現在這個功能要處理什麼」**，請放在 **軌跡**。

---

### **Q: 在軌跡內容有問題，如何修正?**

**A:** 當你在 **軌跡（Track）內容中發現問題（例如：規格寫錯、執行計畫不周全、或 AI 理解偏差）時，修正的核心原則是：「不要直接跳過文件去改程式，而是先修正文件，再讓 AI 根據新文件同步程式。」**

這能確保 AI 的「大腦（計畫）」與「手（程式碼）」始終保持同步。以下是具體的修正步驟：

#### **1. 修改規格文件 (`spec.md`)**

如果問題出在「功能需求」本身（例如：原本說要存資料庫，現在改為傳送到 API），請先修正 `spec.md`。

* **動作：** 手動編輯該 Track 目錄下的 `spec.md`，或對著 AI 說：「更新規格：將資料儲存方式從 Local Storage 改為呼叫 `/api/save` 接口。」  
* **目的：** 確保 AI 明白「最終目標」已經改變。

#### **2. 重新產生或更新執行計畫 (`plan.md`)**

當規格改變後，原本的執行步驟（Plan）就失效了。

* **動作：** 要求 AI 重新評估計畫。指令範例：`/conductor:updatePlan 根據新的規格更新執行步驟，並標記受影響的現有程式碼。`  
* **目的：** 讓 AI 重新拆解任務，避免它按照舊的錯誤邏輯繼續寫下去。

#### **3. 處理「已經寫錯」的程式碼**

如果 AI 已經根據錯誤的軌跡內容產生了程式碼，修正方式如下：

* **情境 A：錯誤不多**  
  直接告訴 AI：「剛才產生的 `AuthService.ts` 邏輯有誤，請根據更新後的 `plan.md` 第 3 步重新重構該檔案。」  
* **情境 B：錯誤嚴重或方向全錯**  
  建議使用 **Git 回退 (Reset/Checkout)** 到該 Track 開始前的狀態，然後讓 AI 在正確的 `plan.md` 基礎上重新執行。

#### **4. 實用的修正指令範本**

在 Gemini Conductor 的 CLI 中，你可以靈活運用以下對話式修正：

* **發現計畫太籠統：** 「計畫的第 2 步太模糊了，請將它拆解成更細的子任務，包含錯誤處理與邊界測試。」  
* **發現 AI 漏掉專案規範：** 「修正計畫：請確保在實作此功能時，遵循專案設定中的 `Naming_Convention` 規範。」  
* **發現規格衝突：** 「目前的規格與 `context.md` 中的安全規範衝突，請修正規格並重新建議實作方式。」

#### **💡 小提醒：保持「軌跡」的整潔**

如果一個軌跡修修補補變得太亂（例如 `plan.md` 已經改了五次），最好的做法是：

1. **放棄該軌跡：** `/conductor:abandonTrack`  
2. **總結教訓：** 紀錄為什麼失敗（例如：需求不明確）。  
3. **重新開啟：** `/conductor:newTrack` 並提供更精確的初始規格。

---

### **Q: 我的 repository 中，有很多專案，這樣我要針對 AAA 專案，進行 Gemini Conductor 嗎?**

**A:** 如果你的 Repository（程式碼庫）裡面包含多個專案（這在開發上稱為 Monorepo 或多專案架構），**強烈建議你要將 Gemini Conductor 的作用範圍「限縮」在 AAA 專案內。**

如果讓 AI 在整個 Repository 的根目錄亂跑，它不僅會消耗大量 Token 去讀取與 AAA 無關的 BBB 或 CCC 專案，還極容易產生「幻覺」，不小心引用到其他專案的程式碼或設定檔。

要針對 AAA 專案使用 Conductor，你有兩種主要的實作方式：

#### **方法一：目錄隔離法（最推薦，最乾淨）**

這是最簡單也最不容易出錯的做法，直接把 AAA 專案當作一個獨立的宇宙來操作。

**執行步驟：**

1. **切換到專案目錄：** 在終端機（Terminal）中，先使用 `cd` 指令進入 AAA 專案的資料夾。
   ```bash
   cd path/to/your/repository/AAA
   ```
2. **在該目錄下初始化：** 執行 `/conductor:setup`。這樣 Conductor 的設定檔（如 `context.md` 或 `.conductor` 隱藏資料夾）就會只建立在 `AAA` 目錄下。  
3. **建立軌跡（Track）：** 之後你在 `AAA` 目錄下建立的任何新任務（`/conductor:newTrack`），AI 就只會讀取 `AAA` 裡面的程式碼和設定，完全不會干擾到其他專案。

#### **方法二：根目錄控管法（適用於專案間有高度共用程式碼）**

如果 AAA 專案必須頻繁讀取 Repository 根目錄下的共用套件（例如 `packages/shared-ui`），你必須在根目錄執行 Conductor，但要**嚴格設定白名單或黑名單**。

**執行步驟：**

1. **在根目錄設定：** 在整個 Repo 的根目錄執行 `/conductor:setup`。
2. **設定忽略清單（Ignore Rules）：** 在 Conductor 的設定中（通常類似 `.conductorignore` 檔案），把不需要的專案排除，防止 AI 去讀取：
   ```plaintext
   # .conductorignore 範例
   /BBB/
   /CCC/
   /docs/
   ```
3. **在 `context.md` 明確宣告：** 在專案設定文件中，明確告訴 AI 這次的焦點在哪裡：  
   「目前的開發焦點是 `/AAA` 目錄下的專案。你可以讀取 `/shared` 目錄下的共用元件，但**絕對禁止**修改 `/BBB` 或 `/CCC` 內的任何檔案。」

#### **總結建議**

* **如果 AAA 是完全獨立的：** 請毫不猶豫使用 **方法一**，直接 `cd` 進去再啟動 Conductor。這能最大程度確保程式碼品質，避免 AI 搞混。  
* **如果專案間會互相依賴：** 使用 **方法二**，但請務必把邊界條件寫清楚。

---

### **Q: 能否採用方法一，但說明好些專案有互相依賴?**

**A:** 採用 **「方法一（目錄隔離）」** 配合 **「跨目錄參照」**，是處理 Monorepo（多專案單一儲存庫）架構的最佳實踐。

這樣做的好處是：AI 的「大腦」會以 AAA 專案為核心，不會被其他不相干的專案干擾，但同時又擁有讀取共用模組的權限。要達到這個效果，你需要在 AAA 專案的 `context.md`（專案設定檔）中，利用**相對路徑（Relative Paths）與明確的權限宣告**來引導 AI。

#### **具體實作步驟**

假設你的資料夾結構如下：

```plaintext
my-repository/
 ├── shared-packages/   (共用的 UI 元件或工具函式)
 ├── BBB-project/       (不相干的專案)
 └── AAA-project/       (你目前要開發的專案)
```

1. **在 AAA 目錄下初始化**  
   開啟終端機，進入 AAA 的專案資料夾並啟動設定：
   ```bash
   cd path/to/my-repository/AAA-project
   /conductor:setup
   ```

2. **在專案設定 (`context.md`) 中宣告依賴關係**  
   打開剛建立的設定檔，並新增一個「架構與依賴（Architecture & Dependencies）」的區塊。你需要明確告訴 AI 三件事：**依賴在哪裡**、**用途是什麼**、以及**修改權限**。

   **`context.md` 撰寫範例：**
   ```markdown
   ## 專案架構與外部依賴 (Architecture & Dependencies)

   本專案 (AAA-project) 存在於一個 Monorepo 環境中。在開發時，請遵循以下跨目錄依賴規則：

   * **核心專案範圍：** `./` (目前目錄，這是你的主要工作區，可以自由修改與新增檔案)。
   * **共用模組依賴：** 本專案依賴上層目錄的共用套件 `../shared-packages`。
       * **用途：** 所有的基礎 UI 元件（如 Button, Modal）與 API 工具函式（如 fetcher.ts）都來自這裡。
       * **權限限制【嚴格遵守】：** 你可以讀取 `../shared-packages` 內的檔案來了解型別與 Props 規格，但**絕對禁止**修改該目錄下的任何程式碼。若發現共用模組缺少你需要的功能，請在 `plan.md` 中提出警告，由人類開發者決定是否擴充。
   * **隔離區：** 嚴禁讀取或修改 `../BBB-project` 的任何內容。
   ```

#### **為什麼這樣設定有效？**

1. **節省 Token 與運算資源：** AI 不會在啟動時去掃描整個 `shared-packages` 或 `BBB-project`，只有當它在 AAA 專案裡看到例如 `import { Button } from '@shared/ui'` 時，它才會根據你給的相對路徑 (`../shared-packages`) 去精準讀取該元件的原始碼。  
2. **保護共用程式碼（Read-Only 防護）：** 透過明確的文字約束，防止 AI 在修 AAA 的 Bug 時，為了便宜行事而「順手」改了共用元件，導致其他依賴該元件的專案壞掉。  
3. **維持軌跡 (Track) 的聚焦：** 你的任務計畫 (`plan.md`) 將會 100% 專注在 AAA 專案的業務邏輯上。

---

### **Q: 在 repository 下目前有 20 個專案，隔離區如何處理?**

**A:** 當你的 Repository 裡面有多達 20 個專案時，如果要在 `context.md` 裡面把剩下的 19 個專案一個一個列入「隔離區」，不僅寫起來痛苦，日後新增專案時也很容易漏掉。

面對這種大型 Monorepo 架構，最聰明的做法是**從「黑名單（排除法）」改為「白名單（放行法）」**。你可以透過以下兩種方式結合，建立一個滴水不漏的防護網：

#### **方法一：使用 `.conductorignore` 檔案（強烈推薦）**

Gemini Conductor 的底層讀取機制與 Git 非常相似。你可以在 AAA 專案的目錄下（或是 Repository 根目錄下）建立一個 `.conductorignore` 檔案，利用星號（Wildcard）直接忽略所有東西，再把需要的資料夾「反向加回來」。

建立一個 `.conductorignore` 檔案並輸入以下內容：
```plaintext
# 1. 先封鎖上一層（或根目錄）的所有資料夾與檔案
../*

# 2. 開放 (Whitelist) 你目前正在開發的專案
!../AAA-project/

# 3. 開放 (Whitelist) 共用的套件目錄
!../shared-packages/
```
這樣一來，AI 的視野在物理層面就被限制住了，它連其他 19 個專案的檔案名稱都看不到，能省下極大的 Token 消耗，並徹底杜絕幻覺。

#### **方法二：在 `context.md` 中採用「全域防護」語法**

除了物理層面的阻擋，在 AI 的「認知層面」（Prompt）也要宣告白名單。你不需要列出 BBB、CCC 等專案，只要用**泛指的語氣**限制它的行為範圍即可。請將原本的隔離區描述替換成這段：

```markdown
## 專案邊界與存取權限 (Project Boundaries & Permissions)

本專案位於包含 20 多個子專案的 Monorepo 中。為確保程式碼安全與避免混淆，請嚴格遵守以下「白名單存取機制」：

1. **唯一工作區 (Read/Write)：** `./` (AAA-project 目錄)
   * 這是你唯一可以新增、修改、刪除檔案的區域。
2. **唯一外部依賴 (Read-Only)：** `../shared-packages`
   * 你只能**讀取**此目錄來參考共用元件與型別，**絕對禁止**修改此目錄內的任何內容。
3. **🛑 隔離防護區 (Strictly Forbidden)：**
   * 除了上述兩個允許的路徑外，**絕對禁止**向上遍歷或存取 `../` 底下的任何其他兄弟目錄（例如其他專案資料夾）。
   * 如果你需要的功能不在 `shared-packages` 中，請停止操作並在 `plan.md` 中通知開發者，不可嘗試從其他專案「偷渡」程式碼。
```

#### **總結**

面對大型專案庫：
1. **設定 `.conductorignore`** 讓 AI 「看不見」其他 19 個專案。  
2. **在 `context.md` 宣告白名單** 讓 AI 知道「就算看到了也不准動」。

透過這雙重防護，你就可以安心地在 AAA 專案裡使用 Conductor，不用擔心它去把別的專案搞壞了。

---

### **Q: Spec Kit 與 Gemini Conductor 有什麼不同?**

**A:** **GitHub 推出的 Spec Kit** 與 **Google 推出的 Gemini Conductor**，兩者的誕生都是為了解決同一個痛點：**「傳統 AI 寫程式常常寫到一半就忘記脈絡（Vibe Coding 的混亂），需要一個框架來約束它。」**

雖然目標一致，但它們的**核心哲學、支援生態與運作邏輯**有著顯著的不同。簡單來說：**Spec Kit 是一套跨 AI 平台的「規格標準」，而 Conductor 則是專為 Gemini 打造的「持久化記憶系統」。**

以下為您整理兩者的核心差異：

#### **1. 核心差異比較表**

| 比較維度 | GitHub Spec Kit | Gemini Conductor |
| :--- | :--- | :--- |
| **主導者與生態系** | **GitHub** 官方開源專案。設計為 **AI 工具中立**，可搭配 Claude Code、Gemini CLI、Cursor 或 Copilot 使用。 | **Google** 為 Gemini CLI 推出的官方擴充功能。專為 Gemini 的底層邏輯深度定製。 |
| **核心開發哲學** | **規格驅動開發 (SDD)**：一切以 `spec.md` 或 YAML 規格檔為尊，強制按部就班。 | **脈絡驅動開發 (CDD)**：強調 AI 的「長期記憶」，以專案全局架構為中心，局部進行軌跡（Track）開發。 |
| **工作流程** | 極度嚴格的四步法： 1. `/specify` (寫規格) 2. `/plan` (寫計畫) 3. `/tasks` (拆任務) 4. `/implement` (實作) | 較為彈性的軌跡制： 1. `/conductor:setup` (全域設定) 2. `/conductor:newTrack` (開新任務) |
| **檔案管理方式** | 專注於生成一份完美的規格與任務清單，適合把抽象意念轉化為具體文件。 | 會在專案內建立 `product.md`、`techstack.md` 與 `tracks.md`，把 AI 過去做過的事當作記憶存下來。 |
| **最適合的場景** | **從 0 到 1 的全新專案**。強迫開發者把需求想得非常清楚再動手。 | **從 1 到 100 的現有專案（Brownfield）**。AI 能讀懂現有架構並記住先前的開發歷史。 |

#### **2. 深入理解：GitHub Spec Kit 的特色**

Spec Kit 的核心概念是 **「把規格當作合約 (Living Document)」**。

* **跨平台協作：** 這是它最大的殺手鐧。你可以用 Spec Kit 的 `/specify` 讓 Claude 幫你寫出完美的規格書，然後用 `/tasks` 切割任務，最後把這些任務丟給 Cursor 裡的 Copilot 或是 Gemini CLI 來寫程式碼。它讓多種 AI 共享同一個「大腦」。  
* **強制防呆：** 它的流程非常線性。如果你不先完成 `/plan` 決定技術棧，它不會讓你進入 `/tasks`。這種嚴格的步驟能有效防止 AI 產生幻覺或暴走。

#### **3. 深入理解：Gemini Conductor 的特色**

Gemini Conductor 的核心概念是 **「賦予 AI 長期記憶」**。

* **歷史軌跡 (`tracks.md`)：** 當你用 Conductor 完成一個登入功能後，它會把這個經驗記錄在 `tracks.md` 裡。下一次你要開發購物車時，AI 會去讀取軌跡，知道「喔，這個專案已經有登入系統了，我可以直接呼叫既有的 Auth API」，而不會像一般聊天機器人一樣每次都要重新解釋。  
* **全局約束 (`techstack.md`)：** 你在一開始定義好技術棧後，Conductor 在每次生成 `plan.md` 時都會自動去核對，確保 AI 不會突然幫你引入一個你不需要的函式庫。

#### **總結：您應該選哪一個？**

* **選擇 Spec Kit 如果：** 你的團隊正在起草一個**全新的專案**，或者你們團隊內部同時混用了多種 AI 工具（有人用 Cursor，有人用 Claude），需要一個中立的標準規格來統一大家的步調。  
* **選擇 Gemini Conductor 如果：** 你正在維護一個**已經有大量程式碼的現有專案**，且你主要依賴 Gemini CLI 作為你的開發助理。你希望 AI 能「記住」這幾個月來你們專案架構的演進，而不是每次開啟終端機都要重新 Context dumping（餵資料）。

---

### **Q: Gemini Conductor 不是也有 plan 與 implement 嗎?**

**A:** 事實上，**GitHub Spec Kit 和 Gemini Conductor 兩者都信奉同一個核心哲學：「規格驅動開發（Spec-Driven Development, SDD）」。** 它們都極度討厭 AI 盲目地瞎寫程式（業界稱為 Vibe Coding），因此都強制要求 AI 必須遵循 **「寫規格 ➡️ 列計畫 ➡️ 拆任務 ➡️ 實作（Implement）」** 的黃金流程。既然兩者的核心步驟幾乎一樣，那它們**真正的差別**到底在哪裡？主要在於 **「誰來推進流程」** 以及 **「跨平台的通用性」**：

#### **1. 驅動方式：手動打檔 vs. 自動排檔**

* **GitHub Spec Kit（像手排車）：** 它比較像是一套「標準作業流程（SOP）範本」。在實作時，你需要**手動**一步步推動 AI：  
  1. 輸入 `/speckit.specify` ➡️ AI 寫出規格，停下來等你確認。  
  2. 輸入 `/speckit.plan` ➡️ AI 寫出技術計畫，停下來等你確認。  
  3. 輸入 `/speckit.tasks` ➡️ AI 將計畫拆成任務清單。  
  4. 最後才讓 AI 開始實作（Implement）。 **優點是：** 人類在每一個節點都有絕對的控制權，可以隨時煞車修改。  
* **Gemini Conductor（像自排車）：** 它是一個**自動化的工作流引擎**。當你輸入 `/conductor:newTrack` 並給予一個任務目標後，Conductor 會**自動在背景編排**這個流程。它會自己去讀取全局設定、自己生出 `spec.md`、接著生出 `plan.md`，然後就準備開始實作（Implement）。 **優點是：** 流程更順暢，開發者不需要反覆輸入不同的指令來切換階段，Conductor 會在背後把這些檔案都管理好。

#### **2. 記憶的持久度：單次任務 vs. 專案全局**

* **GitHub Spec Kit：** 雖然它也有 `constitution.md`（憲法/最高原則）來規範 AI，但它主要聚焦於 **「把當下這個功能完美地做出來」**。  
* **Gemini Conductor：** Conductor 的防護網更深。它除了 Plan 和 Implement，還多了 `product.md`、`techstack.md`（技術棧）和最重要的 **`tracks.md`（歷史軌跡）**。在 Conductor 實作之前，它會被強制要求去比對過去的軌跡，確保它現在的 Plan 不會破壞上個禮拜做好的功能。

#### **3. 生態系綁定**

* **GitHub Spec Kit：** 它是 **AI 工具中立** 的。你可以今天用 Claude Code 跑它的 Plan，明天用 GitHub Copilot CLI 跑它的 Implement。  
* **Gemini Conductor：** 它是專為 **Gemini CLI** 深度定製的擴充功能，底層邏輯是為了解決 Gemini 模型在處理長文本和多步驟任務時的痛點所打造。

#### **總結來說**

你說得完全沒錯，兩者都有 Plan 與 Implement。 **Spec Kit** 是一套「任何人、任何 AI 都可以用的 **開發框架/範本**」；而 **Gemini Conductor** 則是把這套框架做成了「Gemini 專用的 **自動化輔助外掛**」。如果您喜歡每一個步驟（規格 ➡️ 計畫 ➡️ 實作）都由您親自下指令檢閱，那 Spec Kit 會讓您很有安全感；如果您希望下達一個 Track 後，AI 就把這些文件自動建好並開始幹活，那 Conductor 會更有效率。

---

### **Q: 這樣我如何先定義整個架構?**

**A:** **在讓 AI 寫任何一行程式碼之前，先把「地基（整體架構）」打好，是避免後續專案失控的唯一方法。**

無論您最終決定使用哪一種工具（Gemini Conductor 或其他類似工具），定義整體架構的標準做法都是 **建立一份全局的脈絡文件（通常命名為 `context.md` 或 `architecture.md`）**，並將其作為整個專案的「最高指導原則」。

以下是具體落實架構定義的實作步驟：

#### **第一階段：撰寫架構文件的五大核心**

您不需要一開始就把每個 API 的欄位都寫死，但您必須在全局文件中明確定義以下五個維度。這份文件就像是給 AI 的「員工手冊」：

| 架構維度 | 說明與撰寫重點 | 範例內容 |
| :--- | :--- | :--- |
| **1. 系統願景與目標** | 用一句話或一段話定義這個專案的本質，讓 AI 了解商業邏輯。 | 「這是一個 B2B 的內部請款系統，重視資料安全性與操作的穩定性，不需要花俏的動畫。」 |
| **2. 技術選型 (Tech Stack)** | 明確列出前端、後端、資料庫與核心套件的**具體版本**。 | 「前端：Next.js 14 (App Router) + TypeScript UI：Tailwind CSS + shadcn/ui 資料狀態：Zustand」 |
| **3. 目錄結構與職責** | 規定哪種程式碼應該放在哪個資料夾，避免 AI 亂建目錄。 | 「/components/ui：無狀態的純 UI 元件 /lib/api：所有與後端溝通的 fetch 邏輯 /hooks：自訂的 React Hooks」 |
| **4. 資料流與架構模式** | 說明系統的資料是如何傳遞的（例如 MVC、Clean Architecture）。 | 「採用 JWT 驗證，Token 必須存在 HttpOnly Cookie 中。API 請求統一由 apiClient.ts 攔截器處理。」 |
| **5. 限制與品質規範** | 列出**絕對禁止** AI 做的事情（這非常重要，能省下大量除錯時間）。 | 「1. 嚴禁使用 any 型別。 2. 嚴禁將業務邏輯寫在 UI 元件中。 3. 所有的錯誤都必須捕捉並透過 toast 顯示。」 |

#### **第二階段：與 AI 協作完成架構定義**

您不一定要自己從頭到尾把這份文件刻出來，您可以利用 AI 來輔助您完成「定義架構」的工作：

1. **步驟 1：開啟一個「架構規劃」專用對話**  
   在尚未初始化專案前，先開一個普通的 AI 對話視窗，告訴它您的初步構想：「我要開發一個 [專案類型]，預計使用 [技術 A] 和 [技術 B]。請幫我草擬一份 `context.md` 架構文件，需包含目錄結構規範、狀態管理策略以及編碼品質限制。」
2. **步驟 2：人類審核與微調**  
   AI 產出草稿後，您親自檢閱。如果有不符合您習慣的資料夾命名或套件，直接修改那份 Markdown 內容。
3. **步驟 3：將架構寫入專案（鎖定真理來源）**  
   將確認無誤的內容，存成專案根目錄下的 `context.md`（或 Conductor 規定的設定檔位置）。

#### **第三階段：透過軌跡（Tracks）驗證架構**

架構定義好之後，不要馬上讓 AI 寫複雜的功能。先用一個最簡單的任務來「測試」AI 有沒有讀懂您的架構。

1. **建立第一個測試軌跡：** 建立一個簡單的任務，例如「新增一個全域的 Button 元件」。  
2. **觀察 AI 行為：** 檢查 AI 是否有乖乖把檔案放在您定義的 `/components/ui` 目錄下？是否使用了您規定的 Tailwind CSS？是否有加上 TypeScript 型別？  
3. **修正架構文件：** 如果 AI 做錯了，不要只是罵它，而是去修改您的 `context.md`，把規則寫得更嚴格、更沒有歧義。

---

### **Q: ＳＤＤ與ＣＤＤ有什麼不同?**

**A:** 在 AI 輔助開發的領域中， **SDD（規格驅動開發）** 與 **CDD（脈絡驅動開發）** 代表了兩種不同「引導 AI 寫程式」的哲學。簡單來說：**SDD 專注於「這次任務的藍圖」，而 CDD 專注於「整個專案的記憶與環境」。**

以下為您拆解這兩者的核心差異與應用場景：

#### **1. 核心概念對比**

| 比較維度 | SDD (Specification-Driven Development) 規格驅動開發 | CDD (Context-Driven Development) 脈絡驅動開發 |
| :--- | :--- | :--- |
| **核心精神** | **合約至上。** 規格沒寫清楚前，一行程式碼都不准動。 | **環境至上。** 不了解專案歷史與整體架構前，不准動手。 |
| **關注焦點** | **微觀（Micro）：** 聚焦於「當下這個功能」的輸入、輸出與邊界條件。 | **宏觀（Macro）：** 聚焦於「專案全局」的技術棧、歷史軌跡與共用模組。 |
| **代表性文件** | `spec.md` (單一功能的規格書) | `context.md`、`tracks.md` (專案全局設定與歷史) |
| **防呆機制** | 防止 AI **「寫錯邏輯」**（例如：忘記處理 Error 或 API 格式錯）。 | 防止 AI **「破壞架構」**（例如：擅自引入新套件、改壞別人的 Code）。 |
| **現實生活比喻** | 發包給外包公司的 **「需求規格書」**。 | 讓新員工報到時讀的 **「員工手冊與系統架構圖」**。 |

#### **2. 深入理解：SDD 規格驅動開發**

**SDD 的假設是：「AI 的幻覺來自於需求模糊。」**

在 SDD 的工作流中（例如前面提到的 GitHub Spec Kit），開發者被強迫在動手前，把抽象的想法轉化為具體的規格。

* **運作方式：** 你不能只對 AI 說「幫我做一個購物車」。你必須先產出一份 `spec.md`，裡面明確記載：購物車資料存在哪裡？最多能放幾項商品？按結帳會呼叫哪個 API？  
* **優勢：** 產出的程式碼 **品質與準確度極高**，因為 AI 只是把人類確認過的邏輯「翻譯」成程式碼。  
* **劣勢：** 缺乏全局觀。如果專案很大，AI 可能完美地寫出了一個購物車，但它不知道專案裡早就有一支寫好的 `CartCalculator` 工具函式，於是它又自己造了一次輪子。

#### **3. 深入理解：CDD 脈絡驅動開發**

**CDD 的假設是：「AI 的破壞力來自於它沒有記憶、不懂你的專案架構。」**

在 CDD 的工作流中（例如 Gemini Conductor），重點在於如何把龐大的專案資訊「餵」給 AI，讓它在寫程式時能考慮到周遭的環境。

* **運作方式：** 在開發新功能前，系統會先讓 AI 讀取 `context.md`（知道這裡是用 Next.js、只能用 Tailwind）、讀取 `tracks.md`（知道上週已經做過登入系統）。當 AI 掌握了這些「脈絡」後，才開始寫計畫。  
* **優勢：** 程式碼的 **一致性極高**。AI 能像資深團隊成員一樣，重用現有的元件、遵守現有的命名規範。  
* **劣勢：** 如果脈絡文件沒有維護好（例如設定檔太亂或充滿過時資訊），AI 會被錯誤的脈絡誤導，導致連環錯誤。

#### **4. 實務上的完美結合**

在現代的高階 AI 開發工具中，這兩者 **並不是互斥的，而是互補的**。一個成熟的 AI 開發流程通常會同時包含 CDD 與 SDD：

1. **先用 CDD 打底：** 建立完善的 `context.md`，定義好專案架構與技術棧（給 AI 長期記憶）。  
2. **再用 SDD 衝刺：** 針對每一個新功能（Track），要求 AI 先寫出 `spec.md`，經過你審查同意後，再開始實作程式碼（確保單次任務準確）。

---

### **Q: 依以上說明，重新整理 Spec Kit 與 Gemini Conductor 有什麼不同，並製作核心差異比較表?**

**A:** 這是一個很好的整理時機。結合我們前面討論過的「規格驅動（SDD）」與「脈絡驅動（CDD）」的概念，以及兩者在「計畫與實作」上的運作邏輯，我為您重新梳理 **GitHub Spec Kit** 與 **Gemini Conductor** 的核心差異。雖然這兩套工具的最終目的都是 **「防止 AI 瞎寫程式，強迫它先思考再動手」**，但它們在設計哲學、控制權歸屬與記憶延續性上，有著截然不同的路線。

#### **核心差異比較表**

| 比較維度 | GitHub Spec Kit | Gemini Conductor |
| :--- | :--- | :--- |
| **主導生態系** | **GitHub**（開源中立） | **Google**（Gemini CLI 專屬擴充） |
| **核心開發哲學** | **規格驅動開發 (SDD)** 著重於「當下這個任務的完美藍圖」。 | **脈絡驅動開發 (CDD)** 著重於「專案全局架構與歷史記憶」。 |
| **工具相容性** | **跨平台 (AI-Agnostic)** 可搭配 Cursor、Claude Code、Copilot 甚至 Gemini 使用。 | **深度綁定** 專為 Gemini CLI 與 Gemini 模型底層邏輯量身打造。 |
| **工作流控制感** | **手動步進（手排車）** 需人為介入推動： `/specify` ➡️ `/plan` ➡️ `/tasks` ➡️ `/implement` | **自動編排（自排車）** 給予目標後背景自動化： `/conductor:newTrack` (自動產出 Spec ➡️ Plan ➡️ 實作) |
| **記憶與狀態管理** | **單次任務聚焦** 主要依賴單一份 `spec.md` 作為真理來源，任務完成即結束。 | **長期累積制** 擁有 `context.md` (全域設定) 與 `tracks.md` (軌跡紀錄)，AI 會記得上週做過的事。 |
| **程式碼防護機制** | 依賴人類在 `/plan` 階段仔細檢查，防止 AI 寫錯業務邏輯。 | 依賴「白名單/隔離區」限制 AI 視野，並有 **自動化審查（Automated Reviews）** 對照規格。 |

#### **深入解析：三大關鍵差異**

1. **跨平台通用 vs. 深度原生定製**  
   * **Spec Kit** 就像是一套「公版 SOP」。它的價值在於提供一套任何人、任何 AI 都能讀懂的 Markdown 格式標準。這意味著您的團隊如果混用多種 AI 工具，Spec Kit 是很好的溝通橋樑。  
   * **Gemini Conductor** 則是 Google 為了解決 Gemini 處理大型專案時的痛點所開發的「專屬大腦」。它能最大化利用 Gemini 的長文本優勢（Long Context Window），把整個專案的歷史軌跡都吃進去處理。

2. **控制權：手動把關 vs. 自動化推進**  
   * **Spec Kit** 極度強調 **人類的節點控制**。AI 寫完規格（Spec）後，必須等您點頭，才能進入計畫（Plan）；計畫切成任務（Tasks）後，還要等您確認，才會開始寫程式（Implement）。它不容許 AI 自作主張。  
   * **Gemini Conductor** 雖然也有 Spec 和 Plan，但它傾向於 **「給我一個方向，我幫你跑到好」**。在開啟一個新 Track 後，它會自動生成計畫並直接嘗試實作，適合希望提高開發速度，並依賴 Git Diff 來做最後驗收的開發者。

3. **記憶長度：單點突破 vs. 歷史累積**  
   * **Spec Kit** 擅長處理「從 0 到 1」或「單一且複雜度極高」的功能。它確保這次的需求不會被做歪。  
   * **Gemini Conductor** 則像是一個「跟著專案一起成長的員工」。因為有 Track（軌跡）系統，它知道您之前已經寫過哪些共用元件、踩過哪些坑，所以在處理「從 1 到 100」的現有專案維護時，它更不容易破壞原本的架構。

---

### **Q: 依以上說明，重新整理 Spec Kit 與 Gemini Conductor 有什麼不同，並製作核心差異比較表?**

**A:** 結合我們討論過的「規格驅動（SDD）」與「脈絡驅動（CDD）」，以及兩者在「人類介入時機」上的真實運作邏輯，我為您重新整理了一份最精確的核心差異比較。這兩套工具的終極目標都是 **「拒絕 AI 盲寫（Vibe Coding），強迫先思考再動手」**，但它們在推進流程的方式與記憶持久度上有著根本的不同。

#### **🌟 Spec Kit 與 Gemini Conductor 核心差異比較表**

| 比較維度 | GitHub Spec Kit | Gemini Conductor |
| :--- | :--- | :--- |
| **主導生態系與定位** | **GitHub** 官方開源。 AI 中立標準（可搭配任何 AI 工具如 Cursor, Copilot 等使用）。 | **Google** 官方擴充。 專為 Gemini CLI 與 Gemini 模型底層邏輯深度定製。 |
| **核心開發哲學** | **規格驅動開發 (SDD)** 焦點在「當下」。確保這一次任務的需求與邊界被完美定義。 | **脈絡驅動開發 (CDD)** 焦點在「全局」。確保 AI 記住整個專案的架構、限制與歷史。 |
| **記憶與狀態管理** | **單次任務聚焦** 以單份 `spec.md` 為真理來源，任務做完，這份合約就結束了。 | **長期累積制 (Tracks)** 擁有 `context.md` (全域) 與 `tracks.md` (軌跡)，AI 會記住上週做過什麼、踩過什麼坑。 |
| **工作流控制機制** | **指令推動（手動步進）** 人類不輸入下一個指令，流程就不會動。 `/specify` ➡️ `/plan` ➡️ `/tasks` ➡️ `/implement` | **檢查點引導（Human-in-the-loop）** 啟動 `/conductor:newTrack` 後會自動編排文件，但在 **計畫產出後** 與 **階段完成時** 會強制暫停，等待人類審核放行。 |
| **程式碼防護重點** | 依賴人類在 `/plan` 階段仔細檢查，防止 AI 寫錯業務邏輯。 | 依賴「目錄隔離 / .conductorignore」限制視野，並具備 **自動化審查** 對照規格。 |
| **最適合的應用場景** | **從 0 到 1 的全新專案**，或是需要極度嚴謹定義的單一複雜功能。 | **從 1 到 100 的大型/既有專案**（如您提到有 20 個專案的 Monorepo），需要 AI 懂架構且不破壞現狀。 |

#### **深入解析：三大關鍵差異重新聚焦**

1. **控制權的本質：指令推動 vs. 檢查點把關**  
   這正是我們剛剛釐清的最重要區別：
   * **Spec Kit 就像是「回合制遊戲」：** 你必須明確輸入指令，AI 才會做下一個動作。這種方式給予開發者絕對的微觀控制權，適合心思細膩、希望參與每一個決策環節的人。  
   * **Gemini Conductor 就像是「帶有輔助駕駛的導航」：** 你給予一個目標（建立新 Track），它會自動把該準備的文件（Spec, Plan）都寫好，但**絕對不會擅自踩油門寫程式**。它會停在「檢查點（Checkpoint）」問你：「計畫長這樣，同意嗎？」你點頭後，它才進入實作。

2. **AI 記憶的延續性：拋棄式 vs. 累積式**  
   * **Spec Kit** 產生的是一份份完美的規格書。當這個功能開發完畢，這份規格書的歷史任務就達成了，下一次開發新功能時，通常又是從新的 `/specify` 開始。  
   * **Gemini Conductor** 的 Track 系統會將開發歷史寫入專案的 `tracks.md` 中。這代表 AI 是會「成長」的。它會知道 AAA 專案在兩個月前已經把驗證系統改為 JWT，所以今天在寫新 API 時，它會自動帶入這個脈絡。

3. **解決痛點的不同**  
   * 如果您的痛點是： **「團隊需求總是很模糊，AI 寫出來的東西跟我想的都不一樣。」** ➡️ 選擇 **Spec Kit**，強迫大家把規格寫清楚。  
   * 如果您的痛點是： **「AI 常常亂引套件、改 A 壞 B，甚至跑到其他專案目錄去亂動程式碼。」** ➡️ 選擇 **Gemini Conductor**，用嚴格的脈絡隔離與白名單管好它。

---

### **Q: 說明 Gemini Conductor 所開的 Tracks，是否刪除? 刪除會有什麼影響?**

**A:** 
#### **1. 軌跡（Tracks）可以刪除嗎？**
是的，絕對可以。因為 Gemini Conductor 的核心精神是將狀態直接存放在「本地端的 Markdown 檔案」中（通常位於專案下的 `conductor/tracks/` 目錄），所以你對這些檔案擁有 100% 的控制權。

你可以透過以下兩種方式刪除：
* **優雅地放棄（指令操作）：** 如果是進行到一半的任務，可以使用 `/conductor:abandonTrack` 指令，系統會安全地終止該任務並清理當前的執行狀態。  
* **物理刪除（手動操作）：** 直接在你的開發環境（如 VS Code）中，把該 Track 對應的資料夾或 Markdown 檔案直接刪除（Delete）。

#### **2. 刪除軌跡會有什麼影響？**
刪除軌跡所造成的影響，完全取決於這個軌跡是處於 **「進行中」** 還是 **「已完成」** 的狀態：

* **情境 A：刪除「進行中」的軌跡**  
  通常發生在你發現 AI 誤解了需求、計畫（Plan）寫得太爛，或是需求突然大改的時候。
  * **中斷任務：** AI 會立刻「忘記」這個任務，停止後續的所有實作步驟。  
  * **程式碼不會自動還原（⚠️ 關鍵注意）：** 刪除軌跡檔案**只會刪除 AI 的計畫書，並不會還原 AI 已經改動過的程式碼**。如果你希望一切重來，必須先透過 Git 指令（如 `git reset --hard` 或 `git checkout`）將程式碼回退到乾淨的狀態，再刪除軌跡。  
  * **結果：** 這是健康的開發日常。發現走錯路，果斷刪除並用 `/conductor:newTrack` 重新定義規格是很好的做法。

* **情境 B：刪除「已完成」的軌跡**  
  通常發生在開發者覺得專案裡多了一堆 Markdown 檔案，想做個大掃除的時候。
  * **喪失長期記憶（⚠️ 負面影響）：** Gemini Conductor 的強大之處（即「脈絡驅動 CDD」）就在於它會把過去的軌跡當作「經驗值」。如果你刪除了開發「登入系統」的軌跡，下次你要做「忘記密碼」功能時，AI 就會失去當初設計登入系統時的上下文脈絡（例如使用了哪個加密套件、狀態存在哪裡）。  
  * **架構漂移風險：** 因為 AI 發生了「失憶症」，未來的開發可能會出現風格不一致、重複造輪子，甚至寫出與既有架構衝突的邏輯。  
  * **結果：** **強烈不建議**刪除已完成的軌跡。它們是 AI 的記憶庫，也是專案極具價值的歷史文件。

#### **💡 給您的最佳實務建議**
如果您覺得軌跡檔案太多、版面看起來很亂，建議採用以下方式管理，而不是直接刪除：
1. **善用摺疊與目錄管理：** 讓它們安靜地躺在特定的目錄（例如 `conductor/tracks/`）下即可，平時開發不需要打開它們。  
2. **版本控制歸檔：** 既然它們是文字檔，就大方地把它們 Commit 進 Git 裡。這不僅是 AI 的記憶，也是未來新同事報到時，最完美的「決策歷史紀錄（ADR, Architecture Decision Records）」。

---

### **Q: 若這個系統預計營運 20 年才能下線，這 20 年會不斷新增功能，這樣有什麼配套?**

**A:** 【事實檢查思考】
1. **問題本質：** 系統營運 20 年且不斷新增功能，在軟體工程中屬於超長生命週期的遺留系統（Legacy System）演進挑戰。  
2. **AI 工具的物理限制：** 基於前文探討的「脈絡驅動開發（CDD）」與「軌跡（Tracks）」機制，若 20 年來的所有任務軌跡（Markdown 檔案）只增不減，絕對會超出 AI 模型的「上下文長度限制（Context Window）」，同時也會夾雜大量過時的歷史雜訊，導致 AI 判斷失準。  
3. **解決方向：** 必須結合經業界驗證的軟體工程實踐（如架構決策紀錄 ADR、脈絡壓縮、自動化測試、模組化架構），不能單純依賴 AI 開發工具的預設記憶功能。

針對一個預計營運 20 年且會持續長大的系統，若要使用 AI 輔助開發（如 Gemini Conductor 或類似的脈絡驅動工具），最大的挑戰在於 **「如何防止 AI 被龐大且過時的歷史記憶壓垮」**。為了確保 AI 在第 15 年時依然能精準寫出符合當下架構的程式碼，您必須在專案初期就建立以下五大配套措施：

#### **配套一：脈絡壓縮與知識萃取（Context Compression）**
20 年會產生數以萬計的「軌跡（Tracks）」，AI 不可能每次都讀完。
* **定期總結：** 當一個大型模組（例如：購物車系統）穩定後，不該再讓 AI 每次去讀過去那 50 個修 Bug 的微小軌跡。開發團隊應該將這些軌跡的「核心業務邏輯」萃取出來，更新到該目錄下的 `context.md` 中。  
* **歷史封存（Archive）：** 將已經提煉過的舊軌跡移至 `archive/` 資料夾，並在 `.conductorignore`（或隔離區設定）中將其排除，只保留最新、最核心的系統現狀給 AI 讀取。

#### **配套二：導入「架構決策紀錄（ADR）」**
在 20 年的長河中，技術棧一定會更迭（例如從 React 換成未來的某個新框架）。
* **配套作法：** 在專案中建立 `docs/adr/` 目錄（Architecture Decision Records）。這比單純的軌跡更具結構性。  
* **與 AI 協作：** 每次發生重大架構變更時，要求 AI 撰寫一份 ADR，記錄「為什麼在 2030 年我們決定放棄 A 技術轉用 B 技術」。這能防止未來的 AI 試圖「自作聰明」把程式碼改回舊的寫法。

#### **配套三：嚴格的領域驅動設計（DDD）與模組化**
絕對不要讓 20 年後的系統變成一個龐大的單體（Monolith），否則 AI 改動任何一行程式碼的風險都極高。
* **配套作法：** 將系統切分為多個獨立的「有界脈絡（Bounded Contexts）」，例如「會員中心」、「結帳系統」、「報表系統」。  
* **精準掛載：** 如同我們前面討論的「目錄隔離法」，當未來要新增報表功能時，AI 的視野（`context.md`）僅限於報表目錄與共用工具庫，嚴禁 AI 讀取或干涉其他無關的領域模組。

#### **配套四：將「自動化測試」視為最終真理來源**
Markdown 寫的規格（Spec）在經過 10 年後，語意可能會變得模糊，甚至與實際程式碼脫節。
* **配套作法：** **測試程式碼不會說謊。** 必須建立極度完善的單元測試與整合測試（E2E 測試）。  
* **AI 防線：** 要求 AI 在生成任何新計畫（Plan）與實作前，必須確保現有的測試皆能通過。即使 AI 誤解了過時的規格文件，CI/CD（持續整合/持續部署）流程中的自動化測試也能成為擋下錯誤的最後一道防線。

#### **配套五：定期更新「負面表列（禁止事項）」**
20 年內會產生很多「不該再用的舊 API」或「已被淘汰的寫法」。
* **配套作法：** 在全域的設定檔中，維護一份動態的 `Deprecated_Rules`（棄用清單）。  
* **範例：** 「禁止使用 `moment.js`，全面改用 `date-fns`」、「舊版的 `/api/v1/auth` 已廢棄，所有新功能必須呼叫 `/api/v2/auth`」。這樣能確保 AI 產出的程式碼永遠符合最新的品質標準，不會因為參考了 5 年前的舊檔案而寫出過時的程式碼。

**總結來說：** 面對 20 年的專案，不能把 AI 當作「全知全能的神」，而是要把它當作「容易失憶、需要明確指引的新進員工」。**透過定期將「零碎的軌跡」壓縮成「結構化的架構文件」，並用「自動化測試」加上護欄**，才是讓 AI 輔助開發能長久穩定運作的不二法門。
